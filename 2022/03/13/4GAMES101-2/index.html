<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>GAMES101 - Assignment2 | Crux - 南十字星</title><meta name="description" content="GAMES101 - Assignment2"><meta name="keywords" content="图形学,入门"><meta name="author" content="Crux"><meta name="copyright" content="Crux"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="GAMES101 - Assignment2"><meta name="twitter:description" content="GAMES101 - Assignment2"><meta name="twitter:image" content="http://cruxssssss.github.io/img/23.jpg"><meta property="og:type" content="article"><meta property="og:title" content="GAMES101 - Assignment2"><meta property="og:url" content="http://cruxssssss.github.io/2022/03/13/4GAMES101-2/"><meta property="og:site_name" content="Crux - 南十字星"><meta property="og:description" content="GAMES101 - Assignment2"><meta property="og:image" content="http://cruxssssss.github.io/img/23.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://cruxssssss.github.io/2022/03/13/4GAMES101-2/"><link rel="prev" title="hexo blog 之 备份 &amp; 图片显示 &amp; 常见问题" href="http://cruxssssss.github.io/2022/03/15/hexo0/"><link rel="next" title="从4开始的图形学入门生活（Z-buffer &amp; Lambertian (Diffuse) Shading）" href="http://cruxssssss.github.io/2022/03/09/4GAMES101/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://cruxssssss.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: {"languages":{"author":"Author: Crux","link":"Link: http://cruxssssss.github.io/2022/03/13/4GAMES101-2/","source":"Source: Crux - 南十字星","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"Press","message_next":"to bookmark this page"},"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Light Mode Activated Manually","night_to_day":"Dark Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Crux - 南十字星</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/ppap.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">6</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Assignment"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Assignment</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Tips-about-C"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Tips about C++</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#迭代器std-begin-和std-end"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">迭代器std::begin()和std::end()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#std-transform"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">std::transform</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Eigen的vector取头尾或切片"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">Eigen的vector取头尾或切片</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#std-vector"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">std::vector</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#std-array"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">std::array</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简介"><span class="toc_mobile_items-number">2.5.1.</span> <span class="toc_mobile_items-text">简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#array-容器的用法"><span class="toc_mobile_items-number">2.5.2.</span> <span class="toc_mobile_items-text">array 容器的用法</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#函数实现"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">函数实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#rasterize-triangle"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">rasterize_triangle</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建三角形的2维bounding-box"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">创建三角形的2维bounding box</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#思路"><span class="toc_mobile_items-number">3.1.1.1.</span> <span class="toc_mobile_items-text">思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实现"><span class="toc_mobile_items-number">3.1.1.2.</span> <span class="toc_mobile_items-text">实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#遍历像素，检查中心点是否在三角形内"><span class="toc_mobile_items-number">3.1.2.</span> <span class="toc_mobile_items-text">遍历像素，检查中心点是否在三角形内</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#遍历"><span class="toc_mobile_items-number">3.1.2.1.</span> <span class="toc_mobile_items-text">遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#insideTriangle"><span class="toc_mobile_items-number">3.1.2.2.</span> <span class="toc_mobile_items-text">insideTriangle()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Z-buffer"><span class="toc_mobile_items-number">3.1.3.</span> <span class="toc_mobile_items-text">Z-buffer</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MSAA"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">MSAA</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Common-Setting"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">Common Setting</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#MSAA-code"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">MSAA code</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#minDepth-amp-count"><span class="toc_mobile_items-number">3.2.2.1.</span> <span class="toc_mobile_items-text">minDepth &amp; count</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#4倍的depth-buf，4倍的color-buf"><span class="toc_mobile_items-number">3.2.2.2.</span> <span class="toc_mobile_items-text">4倍的depth_buf，4倍的color_buf</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Only-4-倍的depth-buf（no-color-buf）"><span class="toc_mobile_items-number">3.2.2.3.</span> <span class="toc_mobile_items-text">Only 4 倍的depth_buf（no color_buf）</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Total-Code"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Total Code</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-depth-buf-4-color-buf"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">*4 depth_buf, *4 color_buf</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-depth-buf-no-color-buf"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">*4 depth_buf, no color_buf</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Assignment"><span class="toc-number">1.</span> <span class="toc-text">Assignment</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tips-about-C"><span class="toc-number">2.</span> <span class="toc-text">Tips about C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器std-begin-和std-end"><span class="toc-number">2.1.</span> <span class="toc-text">迭代器std::begin()和std::end()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-transform"><span class="toc-number">2.2.</span> <span class="toc-text">std::transform</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eigen的vector取头尾或切片"><span class="toc-number">2.3.</span> <span class="toc-text">Eigen的vector取头尾或切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-vector"><span class="toc-number">2.4.</span> <span class="toc-text">std::vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-array"><span class="toc-number">2.5.</span> <span class="toc-text">std::array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-容器的用法"><span class="toc-number">2.5.2.</span> <span class="toc-text">array 容器的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数实现"><span class="toc-number">3.</span> <span class="toc-text">函数实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rasterize-triangle"><span class="toc-number">3.1.</span> <span class="toc-text">rasterize_triangle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建三角形的2维bounding-box"><span class="toc-number">3.1.1.</span> <span class="toc-text">创建三角形的2维bounding box</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思路"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历像素，检查中心点是否在三角形内"><span class="toc-number">3.1.2.</span> <span class="toc-text">遍历像素，检查中心点是否在三角形内</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insideTriangle"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">insideTriangle()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z-buffer"><span class="toc-number">3.1.3.</span> <span class="toc-text">Z-buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MSAA"><span class="toc-number">3.2.</span> <span class="toc-text">MSAA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Common-Setting"><span class="toc-number">3.2.1.</span> <span class="toc-text">Common Setting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSAA-code"><span class="toc-number">3.2.2.</span> <span class="toc-text">MSAA code</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#minDepth-amp-count"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">minDepth &amp; count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4倍的depth-buf，4倍的color-buf"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">4倍的depth_buf，4倍的color_buf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Only-4-倍的depth-buf（no-color-buf）"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">Only 4 倍的depth_buf（no color_buf）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Total-Code"><span class="toc-number">4.</span> <span class="toc-text">Total Code</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-depth-buf-4-color-buf"><span class="toc-number">4.1.</span> <span class="toc-text">*4 depth_buf, *4 color_buf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-depth-buf-no-color-buf"><span class="toc-number">4.2.</span> <span class="toc-text">*4 depth_buf, no color_buf</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/23.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">GAMES101 - Assignment2</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2022-03-13<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2022-03-16</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/GAMES101/">GAMES101</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><div class="note info">
            <p>虽然老师说作业2比作业1简单，但是我觉得作业2比较难。</p><p>主要作业2的各个变量和主体框架比较难懂，需要花比较多的时间阅读、弄懂；</p><p>两个函数实现的时候一拿到手会感觉比较难以下手，所以我是参考着别人的代码写出来的；</p><p>还有实现MSAA的时候，会遇到黑线问题，需要自己跟着代码走一遍渲染过程才能知道怎么去掉黑线。</p>
          </div>

<h1 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h1><p>实现rasterizer.cpp中的两个函数：</p>
<ul>
<li><p><code>static bool insideTriangle()</code>: 测试点是否在三角形内。你可以修改此函数的定义，这意味着，你可以按照自己的方式更新返回类型或函数参数。</p>
</li>
<li><p><code>rasterize_triangle()</code>: 执行三角形栅格化算法</p>
<p>该函数的内部工作流程如下：</p>
<ol>
<li>创建三角形的2 维bounding box。</li>
<li>遍历此bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。</li>
<li>如果在内部，则将其位置处的插值深度值(interpolated depth value) 与深度缓冲区(depth buffer) 中的相应值进行比较。</li>
<li>如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区(depth buffer)。</li>
</ol>
</li>
</ul>
<p>提高项：</p>
<p>用super-sampling 处理Anti-aliasing : </p>
<p>你可能会注意到，当我们放大图像时，图像边缘会有锯齿感。我们可以用super-sampling来解决这个问题，即对每个像素进行2 * 2 采样，并比较前后的结果(这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个sample list。最后，如果你实现正确的话，你得到的三角形不应该有不正常的黑边。</p>
<blockquote>
<p>为了方便同学们写代码，我们将z 进行了反转，保证都是正数，并且越大表示离视点越远。</p>
</blockquote>
<h1 id="Tips-about-C"><a href="#Tips-about-C" class="headerlink" title="Tips about C++"></a>Tips about C++</h1><blockquote>
<p>帮助理解作业框架的一些C++知识点</p>
</blockquote>
<h2 id="迭代器std-begin-和std-end"><a href="#迭代器std-begin-和std-end" class="headerlink" title="迭代器std::begin()和std::end()"></a>迭代器<code>std::begin()</code>和<code>std::end()</code></h2><ul>
<li><p>迭代器是一个行为类似于<strong>指针</strong>的模板类对象。只需要迭代器<code>iter</code>指向一个有效对象，就可以通过使用<code>*iter</code>解引用的方式来获取一个对象的引用。 </p>
</li>
<li><p>通常会使用一对迭代器来定义一段元素（任意支持迭代器对象的元素）。一段元素通过<strong>起始迭代器</strong>指向第一个元素，通过<strong>结束迭代器</strong>指向最后一个元素的后一个位置的元素序列。一般使用std::begin()和std::end()来获取容器的迭代器。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> < numeric ></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> < iostream ></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> < iterator ></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">double</span> data[] {<span class="number">2.5</span>,<span class="number">4.5</span>,<span class="number">6.5</span>,<span class="number">5.5</span>,<span class="number">8.5</span>};</span><br><span class="line">    <span class="built_in">cout</span><<<span class="string">"The array contains: \n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">std</span>::<span class="built_in">begin</span>(data) ;iter != <span class="built_in">std</span>::<span class="built_in">end</span>(data) ; ++iter){</span><br><span class="line">        <span class="built_in">cout</span> << *iter << <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">std</span>::accumulate(<span class="built_in">std</span>::<span class="built_in">begin</span>(data),<span class="built_in">std</span>::<span class="built_in">end</span>(data),<span class="number">0.0</span>);  <span class="comment">//std::accumulate()表示计算std::begin()到std::end()之间的元素的总和，并且起始值设置为0</span></span><br><span class="line">    <span class="built_in">cout</span> <<<span class="string">"\n"</span><< total << <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ul>
<h2 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a><code>std::transform</code></h2><p>在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内。要使用<code>std::transform</code>函数需要包含<algorithm>头文件。</algorithm></p>
<p>声明如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryOperation</span>></span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator</span> <span class="title">first1</span>, <span class="title">InputIterator</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryOperation</span> <span class="title">op</span>);</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> <<span class="class"><span class="keyword">class</span> <span class="title">InputIterator1</span>, <span class="title">class</span> <span class="title">InputIterator2</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">BinaryOperation</span>></span></span><br><span class="line"><span class="class">  <span class="title">OutputIterator</span> <span class="title">transform</span> (<span class="title">InputIterator1</span> <span class="title">first1</span>, <span class="title">InputIterator1</span> <span class="title">last1</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">InputIterator2</span> <span class="title">first2</span>, <span class="title">OutputIterator</span> <span class="title">result</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">BinaryOperation</span> <span class="title">binary_op</span>);</span></span><br></pre></td></tr></tbody></table></figure></div>

<ol>
<li><p>一元操作</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//op的一个实现，将[first1, last1)范围内的每个元素加5，然后依次存储到result中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_increase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{<span class="keyword">return</span> (i + <span class="number">5</span>)};</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用std::transform的方式如下</span></span><br><span class="line"><span class="built_in">std</span>::transform(first1, last1, result, op_increase);</span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li><p>二元操作</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//binary_op的一个实现，将first1和first2开头的范围内的每个元素相加，然后依次存储到result中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op_add</span><span class="params">(<span class="keyword">int</span>, a, <span class="keyword">int</span> b)</span> </span>{<span class="keyword">return</span> (a + b)};</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用std::transform的方式如下</span></span><br><span class="line"><span class="built_in">std</span>::transform(first1, last1, first2, result, op_add);</span><br></pre></td></tr></tbody></table></figure></div>
</li>
</ol>
<ul>
<li>std::transform支持in place，即result和first1指向的位置可以是相同的。std::transform的主要作用应该就是省去了我们自己写for循环实现。 </li>
</ul>
<h2 id="Eigen的vector取头尾或切片"><a href="#Eigen的vector取头尾或切片" class="headerlink" title="Eigen的vector取头尾或切片"></a>Eigen的vector取头尾或切片</h2><p>这里的vector指的是<code>Vector3d</code>这种或者<code>Matrix<double, 1 3,></double,></code>这种的列向量</p>
<p>获取向量的前n个元素：<code>vector.head(n)</code>;<br>获取向量尾部的n个元素：<code>vector.tail(n)</code>;<br>获取从向量的第i个元素开始的n个元素：<code>vector.segment(i,n)</code>;</p>
<h2 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h2><p>须添加头文件<vector></vector></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec;　　　　 <span class="comment">// 空对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec(<span class="number">5</span>,<span class="number">-1</span>);　 <span class="comment">// 创建了一个包含5个元素且值为-1的vector</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="built_in">std</span>::<span class="built_in">string</span>> strVec{<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>};　　<span class="comment">// 列表初始化</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>要注意“（）”和“{}”这样的初始化情况，比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec(<span class="number">10</span>，<span class="number">1</span>);　　　　<span class="comment">// 包含10个元素，且值为1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec{<span class="number">10</span>，<span class="number">1</span>};　　　　<span class="comment">// 包含2个元素，值分别为10,1</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>然而，一般在程序中，并不会知道vector的元素个数，故使用以上方式倒显得繁琐，所以可以使用<code>push_back</code>，它会负责将一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端(back)”。比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; ++i)</span><br><span class="line">　　nVec.push_back(i);　　　　<span class="comment">// 压入元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i < nVec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">　　<span class="built_in">std</span>::<span class="built_in">cout</span> << nVec[i] << <span class="built_in">std</span>::<span class="built_in">endl</span>;　<span class="comment">// 输出元素</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>其中<code>size()</code>是获取vector元素的个数，另外vector中可使用<code>empty()</code>来返回vector中是否存在元素，如果为空，则返回true，否则返回false。同时，针对nVec[i]是通过下标运算符来获取对应的vector数值的，千万注意，针对于空的vector，万不可通过下标运算符来添加元素，比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>> nVec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; ++i)</span><br><span class="line">　　nVec[i] = i;　　　　<span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>这样编写代码是错误的，nVec是空的，不包含任何对象。当然也就不可能通过下标来添加或访问任何元素。若要添加请使用<code>push_back</code>。</p>
<p>当然，针对于输出，可使用迭代器iterator来表示，比如上面的例子可写成：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><<span class="keyword">int</span>>::iterator itr = nVec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; itr != nVec.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">　　<span class="built_in">std</span>::<span class="built_in">cout</span> << (*itr)  << <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure></div>

<p>针对于iterator有两种标准库类型：<code>iterator</code> 和 <code>const_iterator</code>。</p>
<p>两者的区别主要是后者类似于常量指针，只能读取不能修改。如果vector对象不是常量，两者均可使用。</p>
<blockquote>
<p>更多可见：<a href="https://blog.csdn.net/tpriwwq/article/details/80609371" target="_blank" rel="noopener">https://blog.csdn.net/tpriwwq/article/details/80609371</a></p>
</blockquote>
<h2 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>C++有一种大小固定的特殊容器std::array，这个容器在<array>头文件中定义。它基本上是对C风格的数组进行了简单包装。</array></p>
<p>用std::array替代C风格的数组会带来很多好处。它总是知道自身的大小；不会自动转换为指针，从而避免了某些类型的bug；具有迭代器，可以方便地遍历元素。</p>
<h3 id="array-容器的用法"><a href="#array-容器的用法" class="headerlink" title="array 容器的用法"></a>array 容器的用法</h3><p>array<int,3> 第一个参数表示数组中元素的类型，第二个表示数组的大小。</int,3></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> < iostream ></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> < array></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>{undefined</span><br><span class="line">   <span class="built_in">array</span><<span class="keyword">int</span>, <span class="number">3</span>> arr = {<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>};</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> <<<span class="string">"Array size = "</span><< arr.<span class="built_in">size</span>() << <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> << <span class="string">"Element 2 = "</span><<arr[<span class="number">1</arr[<span></span>] << <span class="built_in">endl</span>;<br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>注意：C风格的数组和std::array 都具有固定的大小，在编译时必须知道这一点。在运行时数组不会增大或缩小。</p>
<p>如果希望数组的大小是动态的，推荐使用std::Vector 。在vector中添加新元素时，vector 会自动增加其大小。</p>
<h1 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h1><h2 id="rasterize-triangle"><a href="#rasterize-triangle" class="headerlink" title="rasterize_triangle"></a>rasterize_triangle</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle& t) {</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br></pre></td></tr></tbody></table></figure></div>

<p>看框架代码，Triangle对象中有public变量：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3f v[<span class="number">3</span>]; <span class="comment">/*the original coordinates of the triangle, v0, v1, v2 in counter clockwise order*/</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>表示逆时针的三个三角形顶点。</p>
<p><code>toVector4()</code>函数定义：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>< Vector4f, <span class="number">3</span>> Triangle::toVector4() <span class="keyword">const</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>< Eigen::Vector4f, <span class="number">3</span>> res;</span><br><span class="line">    <span class="built_in">std</span>::transform(<span class="built_in">std</span>::<span class="built_in">begin</span>(v), <span class="built_in">std</span>::<span class="built_in">end</span>(v), res.<span class="built_in">begin</span>(), [](<span class="keyword">auto</span>& vec) { <span class="keyword">return</span> Eigen::Vector4f(vec.x(), vec.y(), vec.z(), <span class="number">1.f</span>); });</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>所以v是三角形三个顶点的齐次坐标</p>
<h3 id="创建三角形的2维bounding-box"><a href="#创建三角形的2维bounding-box" class="headerlink" title="创建三角形的2维bounding box"></a>创建三角形的2维bounding box</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>现在有三个顶点的坐标，所以可以根据顶点坐标，得到x和y的min和max。</p>
<p><strong>注意</strong>！！比较容易忽略的点：由于x、y的min和max一般是小数，所以我们要向上或向下取整。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>std::min</code>求最小值：比较三个顶点的x、y，所以可以用嵌套的<code>std::min</code>实现。<code>std::max</code>同理。</p>
<p><code>std::floor</code>&<code>std::ceil</code>：向下取整，向上取整。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">float</span> x_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">   <span class="keyword">float</span> x_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">   <span class="keyword">float</span> y_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">   <span class="keyword">float</span> y_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">x_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(x_min);</span><br><span class="line">   x_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(x_max);</span><br><span class="line">   y_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(y_min);</span><br><span class="line">   y_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(y_max);</span><br></pre></td></tr></tbody></table></figure></div>

<p>上面四个变量围成的矩形就是bounding box。</p>
<h3 id="遍历像素，检查中心点是否在三角形内"><a href="#遍历像素，检查中心点是否在三角形内" class="headerlink" title="遍历像素，检查中心点是否在三角形内"></a>遍历像素，检查中心点是否在三角形内</h3><blockquote>
<p>遍历此 bounding box 内的所有像素（使用其整数索引）。然后，使用像素中心的屏幕空间坐标来检查中心点是否在三角形内。</p>
</blockquote>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>直接用bounding box 的四个变量，嵌套两层for循环即可</p>
<h4 id="insideTriangle"><a href="#insideTriangle" class="headerlink" title="insideTriangle()"></a><code>insideTriangle()</code></h4><p>可以联想到之前学的叉乘</p>
<ul>
<li><p>首先用减法得到从三角形三个顶点出发的六个向量。</p>
</li>
<li><p>已知顶点数据逆时针分布，可以知道如果点在三角形内部，那么向量叉乘的结果应是全都指向自己。这个指向如何表示呢？写代码的时候困扰了我很久，后来才想明白，<strong>因为函数中的Triangle t是经过MVP变换后的t（从main函数可以看出来），光栅化时，创建bounding box 和 检查点是否在三角形 都不考虑z值，把三角形推在一个平面上（个人理解），</strong>在这样的前提下算叉乘，就是相当于计算平面上两个二维向量<code>(x1, y1</code>和<code>(x2, y2)</code>的叉乘（z=0的两个三维向量），最终计算出来的叉积根据公式可得<code>x1y2-x2y1</code>，那么叉积的坐标表示(0, 0, x1y2-x2y1)，根据<code>x1y2-x2y1</code>>0或是<0，可以知道z时指向自己还是指向对面。</p>
</li>
<li><p>一开始我想着用Eigen中的cross函数，但是它返回的是一个向量，比较繁琐（并且考虑了z值（但其实根据三维向量计算的公式，得到的向量的z值和二维的去算的值大小一样的））。</p>
</li>
</ul>
<p>所以，总结来说就是先用减法得到六个向量，然后再用公式算出两两叉乘的z值，从而判断方向，知道点是否在三角形内。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">const</span> Vector3f* _v)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    Vector2f P;</span><br><span class="line">    P << x , y;</span><br><span class="line">    <span class="comment">// TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line">    Vector2f v01 = _v[<span class="number">1</span>].head(<span class="number">2</span>) - _v[<span class="number">0</span>].head(<span class="number">2</span>);</span><br><span class="line">    Vector2f v12 = _v[<span class="number">2</span>].head(<span class="number">2</span>) - _v[<span class="number">1</span>].head(<span class="number">2</span>);</span><br><span class="line">    Vector2f v20 = _v[<span class="number">0</span>].head(<span class="number">2</span>) - _v[<span class="number">2</span>].head(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Vector2f _0p = P - _v[<span class="number">0</span>].head(<span class="number">2</span>);</span><br><span class="line">    Vector2f _1p = P - _v[<span class="number">1</span>].head(<span class="number">2</span>);</span><br><span class="line">    Vector2f _2p = P - _v[<span class="number">2</span>].head(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> z1 = v01[<span class="number">0</span>] * _0p[<span class="number">1</span>] - v01[<span class="number">1</span>] * _0p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> z2 = v12[<span class="number">0</span>] * _1p[<span class="number">1</span>] - v12[<span class="number">1</span>] * _1p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> z3 = v20[<span class="number">0</span>] * _2p[<span class="number">1</span>] - v20[<span class="number">1</span>] * _2p[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z1 > <span class="number">0</span> && z2 > <span class="number">0</span> && z3 > <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="Z-buffer"><a href="#Z-buffer" class="headerlink" title="Z-buffer"></a>Z-buffer</h3><blockquote>
<ol>
<li>如果在内部，则将其位置处的插值深度值(interpolated depth value) 与深度缓冲区(depth buffer) 中的相应值进行比较。</li>
<li>如果当前点更靠近相机，请设置像素颜色并更新深度缓冲区(depth buffer)。</li>
</ol>
</blockquote>
<p>到了这一步其实已经很简单了，只要了解一下框架中的<code>get_index(x,y)</code>,<code>getColor()</code>,<code>set_pixel(point, color)</code>这三个函数怎么用的就可以了。（刚开始做的时候没看懂框架不知道要用这些函数，看了别人的作业才知道的）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (insideTriangle(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t.v))</span><br><span class="line">		{</span><br><span class="line">                  <span class="comment">//get depth</span></span><br><span class="line">			<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">			<span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">			<span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">			z_interpolated *= w_reciprocal;</span><br><span class="line">                  <span class="comment">//z-buffer & color</span></span><br><span class="line">			<span class="keyword">if</span> (z_interpolated < depth_buf[get_index(x,y)])</span><br><span class="line">			{</span><br><span class="line">                      Vector3f color = t.getColor();</span><br><span class="line">				depth_buf[get_index(x,y)] = z_interpolated;</span><br><span class="line">				<span class="function">Vector3f <span class="title">point</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">				<span class="built_in">point</span> << (<span class="keyword">float</span>)x, (<span class="keyword">float</span>)y, z_interpolated;</span><br><span class="line">                      set_pixel(<span class="built_in">point</span>, color);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h2><p>然后我们的重头戏——MSAA，来了！</p>
<blockquote>
<p>用super-sampling 处理Anti-aliasing : </p>
<p>你可能会注意到，当我们放大图像时，图像边缘会有锯齿感。我们可以用super-sampling来解决这个问题，即对每个像素进行2 * 2 采样，并比较前后的结果(这里并不需要考虑像素与像素间的样本复用)。需要注意的点有，对于像素内的每一个样本都需要维护它自己的深度值，即每一个像素都需要维护一个sample list。最后，如果你实现正确的话，你得到的三角形不应该有不正常的黑边。</p>
</blockquote>
<h3 id="Common-Setting"><a href="#Common-Setting" class="headerlink" title="Common Setting"></a>Common Setting</h3><ul>
<li><p>首先，我们可以设定一个bool变量MSAA，用它和if-else的结构来决定我们用已经完成的普通方式还是MSAA的方式光栅化三角形。（和别人代码学的）</p>
</li>
<li><p>如何表示一个像素四个采样点的坐标？用<code>std::vecor</code>√（也是和别人代码学的）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span><eigen::vector2f> pos{</eigen::vector2f></span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.75</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.75</span>},</span><br><span class="line">        };</span><br></pre></td></tr></tbody></table></figure></div>

<p>嵌套0~3的i循环，采样点坐标表示为<code>(x+pos[i][0], y+pos[i][1])</code>。</p>
</li>
</ul>
<h3 id="MSAA-code"><a href="#MSAA-code" class="headerlink" title="MSAA code"></a>MSAA code</h3><p>通过学习别人代码，了解到有三种MSAA的实操方法：</p>
<h4 id="minDepth-amp-count"><a href="#minDepth-amp-count" class="headerlink" title="minDepth & count"></a>minDepth & count</h4><p>MSAA 4X 深度：把一个点看成一个格子，判断里面4个小点是否落在三角形内，然后找到其中插值的最小z值，和帧缓冲中的z值进行比较替换即可。<br>MSAA 4X 颜色：判断有4个小点中有几个小点落入三角形，然后按比例对颜色进行采样即可。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录最小深度</span></span><br><span class="line"><span class="keyword">float</span> minDepth = FLT_MAX;</span><br><span class="line"><span class="comment">// 四个小点中落入三角形中的点的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure></div>

<p>循环一个像素得到四个采样点的最小深度和count数值，然后：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count != <span class="number">0</span>) {</span><br><span class="line">	<span class="keyword">if</span> (depth_buf[get_index(x, y)] > minDepth) {</span><br><span class="line">			Vector3f color = t.getColor() * count / <span class="number">4.0</span>;</span><br><span class="line">			<span class="function">Vector3f <span class="title">point</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">			<span class="built_in">point</span> << (<span class="keyword">float</span>)x, (<span class="keyword">float</span>)y, minDepth;</span><br><span class="line">			<span class="comment">// 替换深度</span></span><br><span class="line">			depth_buf[get_index(x, y)] = minDepth;</span><br><span class="line">			<span class="comment">// 修改颜色</span></span><br><span class="line">			set_pixel(<span class="built_in">point</span>, color);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<blockquote>
<p><a href="https://blog.csdn.net/qq_36242312/article/details/105758619" target="_blank" rel="noopener">https://blog.csdn.net/qq_36242312/article/details/105758619</a></p>
</blockquote>
<p>结果：尝试画三角形可以发现，是先画绿三角形再画蓝色三角形，由于这个方法对像素点颜色的设计仅是简单的<code>t.getColor() * count / 4.0</code>，绿色三角形的边缘处像素只会是绿色和黑色的混合颜色，所以绿色三角形和蓝色三角形交界处会有一条黑线。更详细的有图分析：</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_41030550/article/details/104709523" target="_blank" rel="noopener">https://blog.csdn.net/qq_41030550/article/details/104709523</a></p>
</blockquote>
<p>如果想要没有黑线，也就是需要蓝绿三角形交界处是蓝绿色，那么我们就不能简单地对一个像素用它采样点的最小深度值作为它的深度值获取颜色，我们需要的是，一个像素的四个采样点有蓝色有绿色，也就是说，我们需要对每个采样点的深度值进行分析获取颜色。</p>
<p>更直白一点，就是画完绿色三角形后，我们需要可以把绿色三角形边缘像素的黑色采样点画成蓝色，由于蓝色三角形在绿色三角形后面，所以对于深度值的分析，必须是以采样点为单位，所以——我们的深度缓存要扩展为原来的4倍大小。这样，似乎也需要同样大小的空间储存采样点颜色。（有点增加采样率的感觉，只不过四个采样点必须同一个颜色）</p>
<h4 id="4倍的depth-buf，4倍的color-buf"><a href="#4倍的depth-buf，4倍的color-buf" class="headerlink" title="4倍的depth_buf，4倍的color_buf"></a>4倍的depth_buf，4倍的color_buf</h4><p>rasterzier.hpp新增如下代码： </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>< Eigen::Vector3f> color_buf;</span><br></pre></td></tr></tbody></table></figure></div>

<p>rasterzier.cpp改为： </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rst::rasterizer::rasterizer(<span class="keyword">int</span> w, <span class="keyword">int</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h)</span><br><span class="line">{</span><br><span class="line">    frame_buf.resize(w * h);</span><br><span class="line">    depth_buf.resize(w * h * <span class="number">4</span>);</span><br><span class="line">    color_buf.resize(w* h * <span class="number">4</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>后面的个人觉得原作者写的不够好，虽然结果是对的，但是它每判断一个采样点，就要计算一次颜色，设置一次像素，个人觉得这些操作以像素为单位更好，原博客：</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_43399489/article/details/120995939?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&utm_relevant_index=9" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43399489/article/details/120995939?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_paycolumn_v3&utm_relevant_index=9</a></p>
</blockquote>
<p>以下是我自己根据这个方法改进的代码，算是结合了前两个dalao的代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    <span class="keyword">bool</span> MSAA = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (MSAA)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//4 samples</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span><eigen::vector2f> pos{</eigen::vector2f></span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.75</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.75</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//initialize color_buf, 0 means black</span></span><br><span class="line">        <span class="comment">//std::fill(color_buf.begin(), color_buf.end(), Eigen::Vector3f{0, 0, 0}); why?</span></span><br><span class="line">		<span class="comment">//for all samples</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">                <span class="comment">//record min depth</span></span><br><span class="line">                <span class="keyword">float</span> minDepth = FLT_MAX;</span><br><span class="line">                <span class="comment">//have sample in triangle</span></span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>;i++){</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(insideTriangle(x+pos[i][<span class="number">0</span>], y+pos[i][<span class="number">1</span>], t.v)){</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get depth</span></span><br><span class="line">				    	<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					    <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					    <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//update minDepth</span></span><br><span class="line">                        <span class="keyword">if</span>(z_interpolated < depth_buf[get_index(x, y)*<span class="number">4</span> + i]){</span><br><span class="line">                            depth_buf[get_index(x, y)*<span class="number">4</span>+i] = z_interpolated;</span><br><span class="line">                            color_buf[get_index(x, y)*<span class="number">4</span> + i] = t.getColor();</span><br><span class="line">                            flag = <span class="number">1</span>;</span><br><span class="line">                        }</span><br><span class="line">                        </span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(flag){</span><br><span class="line">                    <span class="function">Vector3f <span class="title">color</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>; i++){</span><br><span class="line">                        color += color_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        <span class="keyword">if</span>(depth_buf[get_index(x, y)*<span class="number">4</span> + i] < minDepth)</span><br><span class="line">                        {</span><br><span class="line">                            minDepth = depth_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    color = color/<span class="number">4.0f</span>;</span><br><span class="line">                    set_pixel(Vector3f(x, y, minDepth), color);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>

<p>这样光栅化出来的三角形就有漂亮的蓝绿像素边啦o(<em>￣▽￣</em>)ブ~</p>
<div class="note warning">
            <p>不过我没想明白，为什么当我照葫芦画瓢对<code>color_buf</code>初始化<code>std::fill(color_buf.begin(), color_buf.end(), Eigen::Vector3f{0, 0, 0});</code>之后，得到的结果反而不对 = =</p><p>我不初始化反而成功了</p><p>很怪，留给更大佬的自己破案(•_•)</p>
          </div>

<div class="note success">
            <p>这段代码属于是看起来简单，实际上自己写起来磕磕绊绊地才得到自己想要的结果。</p><p>对本次编写代码帮助最大的一点是，假设有一个 3绿采样点&1蓝色采样点 的像素，假设按顺序(上到下，左到右)绿色采样点的深度分别为123，被覆盖的蓝色采样点深度是2345。</p><p>按照自己写的代码顺序执行，画出各个变量的值、<code>color_buf</code>还有<code>depth_buf</code>的具体存储情况，比如，先画绿色三角形时，<code>depth_buf</code>: | 1 | 2 | ∞ | 3 |，<code>color_buf</code>：| G | G | 0 | G |</p><p>再画蓝色三角形，按照自己写的代码，得到结果是，<code>depth_buf</code>: | 1 | 2 | 4 | 3 |，<code>color_buf</code>：| G | G | B | G |，就是正确的结果，如果不是，那么也可以比较容易发现代码哪里的逻辑有问题√。</p>
          </div>

<h4 id="Only-4-倍的depth-buf（no-color-buf）"><a href="#Only-4-倍的depth-buf（no-color-buf）" class="headerlink" title="Only 4 倍的depth_buf（no color_buf）"></a>Only 4 倍的depth_buf（no color_buf）</h4><p>因为我又看到有bigOld写的代码没有用到<code>color_buf</code>，刚好第一个方法的博客下面评论说把颜色公式改为<code>t.getColor()*count/4.0f + frame_buf[get_index(x,y)] /4.0f</code>可以消除黑边（实践过了，没用，因为必须有4倍的深度缓存才能实现蓝绿混合，不过这给了我一点提示）。我开始思考不用颜色缓存的可能性。</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_41030550/article/details/104709523" target="_blank" rel="noopener">https://blog.csdn.net/qq_41030550/article/details/104709523</a></p>
</blockquote>
<p>在本题的情况下，观察（<code>set_pixel</code>函数）可以知道框架有一个<code>frame_buf</code>，储存的是每个像素我们说好要在屏幕上画的颜色。那么当我们画蓝色三角形的时候，是否可以尝试利用<code>frame_buf</code>中的值知道交界处像素点绿色值，再根据蓝色采样点的情况，算出像素的混合值呢？</p>
<p>假设现在我们知道交界处的蓝色采样点有x个，那么有(4-x)个绿色采样点，这个像素的颜色值就应该是<code>(x*B + (4-x)*G) / 4</code>；又知道frame_buf中该点之前值为<code>((4-x)*G)/4</code>，所以计算color的公式应该是<code>frame_buf(get_index(x, y)) + x*B/4</code>。</p>
<p>我们可以用1中的<code>count</code>变量得到x，代码实现如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MSAA = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (MSAA)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//4 samples</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span><eigen::vector2f> pos{</eigen::vector2f></span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.75</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.75</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//initialize color_buf, 0 means black</span></span><br><span class="line">        <span class="comment">//std::fill(color_buf.begin(), color_buf.end(), Eigen::Vector3f{0, 0, 0}); why?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//for all samples</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">                <span class="comment">//record min depth</span></span><br><span class="line">                <span class="keyword">float</span> minDepth = FLT_MAX;</span><br><span class="line">                <span class="comment">//have sample in triangle</span></span><br><span class="line">                <span class="comment">//bool flag = 0;</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>;i++){</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(insideTriangle(x+pos[i][<span class="number">0</span>], y+pos[i][<span class="number">1</span>], t.v)){</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get depth</span></span><br><span class="line">				    	<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					    <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					    <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//update minDepth</span></span><br><span class="line">                        <span class="keyword">if</span>(z_interpolated < depth_buf[get_index(x, y)*<span class="number">4</span> + i]){</span><br><span class="line">                            depth_buf[get_index(x, y)*<span class="number">4</span>+i] = z_interpolated;</span><br><span class="line">                            <span class="comment">//color_buf[get_index(x, y)*4 + i] = t.getColor();</span></span><br><span class="line">                            <span class="comment">//flag = 1;</span></span><br><span class="line">                            count++;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">//minDepth = std::min(minDepth, z_interpolated);</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(count){</span><br><span class="line">                    <span class="comment">//calculate color</span></span><br><span class="line">                    Vector3f color = t.getColor()*count/<span class="number">4.0f</span> + frame_buf[get_index(x,y)] ;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>; i++){</span><br><span class="line">                        <span class="keyword">if</span>(depth_buf[get_index(x, y)*<span class="number">4</span> + i] < minDepth)</span><br><span class="line">                        {</span><br><span class="line">                            minDepth = depth_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//color = color/4.0f;</span></span><br><span class="line">                    set_pixel(Vector3f(x, y, minDepth), color);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>

<h1 id="Total-Code"><a href="#Total-Code" class="headerlink" title="Total Code"></a>Total Code</h1><h2 id="4-depth-buf-4-color-buf"><a href="#4-depth-buf-4-color-buf" class="headerlink" title="*4 depth_buf, *4 color_buf"></a>*4 depth_buf, *4 color_buf</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle& t) {</span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> x_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">float</span> x_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">float</span> y_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">float</span> y_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    x_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(x_min);</span><br><span class="line">    x_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(x_max);</span><br><span class="line">    y_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(y_min);</span><br><span class="line">    y_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(y_max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">	<span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">	<span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">	<span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">	<span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">	<span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line">    <span class="comment">//采样点坐标(i+0.5 , j+0.5 )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    <span class="keyword">bool</span> MSAA = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (MSAA)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//4 samples</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span><eigen::vector2f> pos{</eigen::vector2f></span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.75</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.75</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//initialize color_buf, 0 means black</span></span><br><span class="line">        <span class="comment">//std::fill(color_buf.begin(), color_buf.end(), Eigen::Vector3f{0, 0, 0}); why?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//for all samples</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">                <span class="comment">//record min depth</span></span><br><span class="line">                <span class="keyword">float</span> minDepth = FLT_MAX;</span><br><span class="line">                <span class="comment">//have sample in triangle</span></span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>;i++){</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(insideTriangle(x+pos[i][<span class="number">0</span>], y+pos[i][<span class="number">1</span>], t.v)){</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get depth</span></span><br><span class="line">				    	<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					    <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					    <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//update minDepth</span></span><br><span class="line">                        <span class="keyword">if</span>(z_interpolated < depth_buf[get_index(x, y)*<span class="number">4</span> + i]){</span><br><span class="line">                            depth_buf[get_index(x, y)*<span class="number">4</span>+i] = z_interpolated;</span><br><span class="line">                            color_buf[get_index(x, y)*<span class="number">4</span> + i] = t.getColor();</span><br><span class="line">                            flag = <span class="number">1</span>;</span><br><span class="line">                        }</span><br><span class="line">                        </span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(flag){</span><br><span class="line">                    <span class="function">Vector3f <span class="title">color</span><span class="params">(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>; i++){</span><br><span class="line">                        color += color_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        <span class="keyword">if</span>(depth_buf[get_index(x, y)*<span class="number">4</span> + i] < minDepth)</span><br><span class="line">                        {</span><br><span class="line">                            minDepth = depth_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    color = color/<span class="number">4.0f</span>;</span><br><span class="line">                    set_pixel(Vector3f(x, y, minDepth), color);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (insideTriangle(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t.v))</span><br><span class="line">				{</span><br><span class="line">                    <span class="comment">//get depth</span></span><br><span class="line">					<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					<span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					<span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					z_interpolated *= w_reciprocal;</span><br><span class="line">                    <span class="comment">//z-buffer & color</span></span><br><span class="line">					<span class="keyword">if</span> (z_interpolated < depth_buf[get_index(x,y)])</span><br><span class="line">					{</span><br><span class="line">                        Vector3f color = t.getColor();</span><br><span class="line">						depth_buf[get_index(x,y)] = z_interpolated;</span><br><span class="line">						<span class="function">Vector3f <span class="title">point</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">						<span class="built_in">point</span> << (<span class="keyword">float</span>)x, (<span class="keyword">float</span>)y, z_interpolated;</span><br><span class="line">                        set_pixel(<span class="built_in">point</span>, color);</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="4-depth-buf-no-color-buf"><a href="#4-depth-buf-no-color-buf" class="headerlink" title="*4 depth_buf, no color_buf"></a>*4 depth_buf, no color_buf</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen space rasterization</span></span><br><span class="line"><span class="keyword">void</span> rst::rasterizer::rasterize_triangle(<span class="keyword">const</span> Triangle& t) {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> v = t.toVector4();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO : Find out the bounding box of current triangle.</span></span><br><span class="line">    <span class="comment">// iterate through the pixel and find if the current pixel is inside the triangle</span></span><br><span class="line">    <span class="keyword">float</span> x_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">float</span> x_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">float</span> y_min = <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">float</span> y_max = <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">1</span>], <span class="built_in">std</span>::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    x_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(x_min);</span><br><span class="line">    x_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(x_max);</span><br><span class="line">    y_min = <span class="built_in">std</span>::<span class="built_in">floor</span>(y_min);</span><br><span class="line">    y_max = <span class="built_in">std</span>::<span class="built_in">ceil</span>(y_max);</span><br><span class="line">    <span class="comment">//bounding box</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If so, use the following code to get the interpolated z value.</span></span><br><span class="line">	<span class="comment">//auto[alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span></span><br><span class="line">	<span class="comment">//float w_reciprocal = 1.0/(alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());</span></span><br><span class="line">	<span class="comment">//float z_interpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();</span></span><br><span class="line">	<span class="comment">//z_interpolated *= w_reciprocal;</span></span><br><span class="line">    <span class="comment">//采样点坐标(i+0.5 , j+0.5 )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.</span></span><br><span class="line">    <span class="keyword">bool</span> MSAA = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (MSAA)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//4 samples</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span><eigen::vector2f> pos{</eigen::vector2f></span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.25</span>},</span><br><span class="line">        {<span class="number">0.25</span>, <span class="number">0.75</span>},</span><br><span class="line">        {<span class="number">0.75</span>, <span class="number">0.75</span>},</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//initialize color_buf, 0 means black</span></span><br><span class="line">        <span class="comment">//std::fill(color_buf.begin(), color_buf.end(), Eigen::Vector3f{0, 0, 0}); why?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//for all samples</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">                <span class="comment">//record min depth</span></span><br><span class="line">                <span class="keyword">float</span> minDepth = FLT_MAX;</span><br><span class="line">                <span class="comment">//have sample in triangle</span></span><br><span class="line">                <span class="comment">//bool flag = 0;</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>;i++){</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(insideTriangle(x+pos[i][<span class="number">0</span>], y+pos[i][<span class="number">1</span>], t.v)){</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get depth</span></span><br><span class="line">				    	<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					    <span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					    <span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					    z_interpolated *= w_reciprocal;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//update minDepth</span></span><br><span class="line">                        <span class="keyword">if</span>(z_interpolated < depth_buf[get_index(x, y)*<span class="number">4</span> + i]){</span><br><span class="line">                            depth_buf[get_index(x, y)*<span class="number">4</span>+i] = z_interpolated;</span><br><span class="line">                            <span class="comment">//color_buf[get_index(x, y)*4 + i] = t.getColor();</span></span><br><span class="line">                            <span class="comment">//flag = 1;</span></span><br><span class="line">                            count++;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">//minDepth = std::min(minDepth, z_interpolated);</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(count){</span><br><span class="line">                    <span class="comment">//calculate color</span></span><br><span class="line">                    Vector3f color = t.getColor()*count/<span class="number">4.0f</span> + frame_buf[get_index(x,y)] ;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i<<span class="number">4</span>; i++){</span><br><span class="line">                        <span class="keyword">if</span>(depth_buf[get_index(x, y)*<span class="number">4</span> + i] < minDepth)</span><br><span class="line">                        {</span><br><span class="line">                            minDepth = depth_buf[get_index(x, y)*<span class="number">4</span> + i];</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//color = color/4.0f;</span></span><br><span class="line">                    set_pixel(Vector3f(x, y, minDepth), color);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = y_min; y <= y_max; y++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = x_min; x <= x_max; x++)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (insideTriangle(x + <span class="number">0.5</span>, y + <span class="number">0.5</span>, t.v))</span><br><span class="line">				{</span><br><span class="line">                    <span class="comment">//get depth</span></span><br><span class="line">					<span class="keyword">auto</span> [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);</span><br><span class="line">					<span class="keyword">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].w() + beta / v[<span class="number">1</span>].w() + gamma / v[<span class="number">2</span>].w());</span><br><span class="line">					<span class="keyword">float</span> z_interpolated = alpha * v[<span class="number">0</span>].z() / v[<span class="number">0</span>].w() + beta * v[<span class="number">1</span>].z() / v[<span class="number">1</span>].w() + gamma * v[<span class="number">2</span>].z() / v[<span class="number">2</span>].w();</span><br><span class="line">					z_interpolated *= w_reciprocal;</span><br><span class="line">                    <span class="comment">//z-buffer & color</span></span><br><span class="line">					<span class="keyword">if</span> (z_interpolated < depth_buf[get_index(x,y)])</span><br><span class="line">					{</span><br><span class="line">                        Vector3f color = t.getColor();</span><br><span class="line">						depth_buf[get_index(x,y)] = z_interpolated;</span><br><span class="line">						<span class="function">Vector3f <span class="title">point</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">						<span class="built_in">point</span> << (<span class="keyword">float</span>)x, (<span class="keyword">float</span>)y, z_interpolated;</span><br><span class="line">                        set_pixel(<span class="built_in">point</span>, color);</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<div class="note info">
            <p>./Rasterizer img.png 可以保存图像， 放大比较好看到抗锯齿效果噢~</p>
          </div>

<div class="note warning">
            <p>完成作业2 MSAA 后的第二大不解的疑问：为什么说用四个采样点中最小的深度值作为像素的深度值更加准确？？（看别人博客这么说的，可能这个问题的前提也不对）</p><p>第三个疑问为什么代码尖括号的转义字符<code><</code>后面必须跟个空格才能显示出来！！！！</p>
          </div></body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Crux</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://cruxssssss.github.io/2022/03/13/4GAMES101-2/">http://cruxssssss.github.io/2022/03/13/4GAMES101-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学    </a><a class="post-meta__tags" href="/tags/%E5%85%A5%E9%97%A8/">入门    </a></div><div class="post_share"><div class="social-share" data-image="/img/23.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2022/03/15/hexo0/"><img class="prev_cover lazyload" data-src="/img/24.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>hexo blog 之 备份 &amp; 图片显示 &amp; 常见问题</span></div></a></div><div class="next-post pull_right"><a href="/2022/03/09/4GAMES101/"><img class="next_cover lazyload" data-src="/img/22.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>从4开始的图形学入门生活（Z-buffer &amp; Lambertian (Diffuse) Shading）</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/02/24/0GAMES101/" title="从0开始的图形学入门生活（Overview & Algebra & Transform）"><img class="relatedPosts_cover lazyload"data-src="/img/17.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-02-24</div><div class="relatedPosts_title">从0开始的图形学入门生活（Overview & Algebra & Transform）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/02/28/2GAMES101/" title="从2开始的图形学入门生活（Rasterization(Triangles) & 作业1）"><img class="relatedPosts_cover lazyload"data-src="/img/20.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-02-28</div><div class="relatedPosts_title">从2开始的图形学入门生活（Rasterization(Triangles) & 作业1）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/01/3GAMES101/" title="从3开始的图形学入门生活（Rasterization-Antialiasing）"><img class="relatedPosts_cover lazyload"data-src="/img/21.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-03-01</div><div class="relatedPosts_title">从3开始的图形学入门生活（Rasterization-Antialiasing）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/09/4GAMES101/" title="从4开始的图形学入门生活（Z-buffer & Lambertian (Diffuse) Shading）"><img class="relatedPosts_cover lazyload"data-src="/img/22.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-03-09</div><div class="relatedPosts_title">从4开始的图形学入门生活（Z-buffer & Lambertian (Diffuse) Shading）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/16/5GAMES101/" title="从5开始的图形学入门生活（Blinn-Phong reflectance model & Shading Frequencies & Graphics Pipeline）"><img class="relatedPosts_cover lazyload"data-src="/img/25.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-03-16</div><div class="relatedPosts_title">从5开始的图形学入门生活（Blinn-Phong reflectance model & Shading Frequencies & Graphics Pipeline）</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/17/6GAMES101/" title="从6开始的图形学入门生活（Texture Mapping & Barycentric coordinates & Mipmap）"><img class="relatedPosts_cover lazyload"data-src="/img/26.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2022-03-17</div><div class="relatedPosts_title">从6开始的图形学入门生活（Texture Mapping & Barycentric coordinates & Mipmap）</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Crux</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>