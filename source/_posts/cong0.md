---
title: 从0开始的C++世界生活（从环境搭建到基本语法）
date: 2020-5-24 15:54:00
tags: 
 - C++
 - 入门
categories: 
 - C++
cover: /img/4.jpg
---

{% note info %}
本系列是学习VC驿站的《实用C++》教程时的超简化同步笔记，详细内容可参见VC驿站原帖
{% endnote %}

{% note warning %}
是在学校C++课程之外重新系统地学习一遍C++，所以很基础很基础的部分不会记录

代码块渲染有误，目前不知道怎么解决，#include< iostream>总是消失，你们自己加上就好了QAQ

{% endnote %}

{% note success %}
希望对你和我都能有所帮助 : ）
{% endnote %}

## 编程开发环境搭建

编译器：Visual Studio 2019

工具：MFC多字节补丁、Visual Assist X（俗称小番茄）、Everything（安装小番茄时可能需要用到）

## C++语言概述

### C++特点

​        C++是由C语言发展而来的，与C兼容。用C语言写的程序基本上可以不加修改地用于C++。从C++的名字可以看出它是C的超集。C++既可用于面向过程的程序设计，又可用于面向对象的程序设计，是一种功能强大的混合型程序设计语言。
​        备注：C++不是纯面向对象语言。

### 和其它语言的区别

~~（这一部分我也看的不是很懂，相信学到后面就会慢慢理解了叭）~~

**编译型语言**

定义：

​        需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。

优点：

​        编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。

缺点：

​        编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。

代表语言：C、C++、Pascal、Object-C 以及最近很火的苹果新语言Swift

**解释型语言**

定义：

​        指用专门解释器对源程序逐行解释成特定平台的机器码并立即执行的语言，相当于把编译型语言的编译链接过程混到一起同时完成的。

特点：

​        解释型语言执行效率较低，且不能脱离解释器运行，但它的跨平台型比较容易，只需提供特定解释器即可。

代表语言：Python（同时是脚本语言）与 Ruby、PHP 等。

**脚本语言**

定义：

​        为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。

特点：

​        程序代码即是最终的执行文件，只是这个过程需要解释器的参与，所以说脚本语言与解释型语言有很大的联系。脚本语言通常是被解释执行的，而且程序是文本文件。

代表语言：JavaScript，Python、Perl 等。

**混合型语言**

描述：

​        既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如 C#，C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.Net在编译成IL代码后，保存在DLL中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。严格来说混合型语言属于解释型语言。C#更接近编译型语言。

代表语言：C#、Java

## VS2019基本使用法

各项设置：工具 -> 选项 中搜索查找

常用子窗口：（视图中设置）

​        左侧：解决方案资源管理器、类视图、资源视图、VA View、VA Outline（大纲）
​        右侧：属性、工具箱
​        上面：主要是工具栏上面的按钮：新建、保存、撤销、重做、启动、Debug、Release、Win32、生成、向后导航、向前导航、文件中查找、注释、取消注释

​        下面：输出、查找结果、断点  

工程文件后缀：sln

### 新建工程类型

~~（也看不太懂，没关系以后一定懂，哭哭）~~

ATL项目

​        主要是跟COM相关的，COM插件等等，比如给OFFICE的Word写插件，给Excel写插件，等等。生成的文件是DLL，比如：VC驿站编程助手，或者比较有名的大漠插件等等一般都是用这种类型的工程创建的；

CLR项目

​        这种类型使用的不是很多，起码我使用的不是很多，他是调用微软的 .Net Framework 库来解析执行代码的项目类型，类似JAVA虚拟机。既然选择了编译类型的语言C++作为开发，所以就没必要在使用CLR了，如果要使用微软的 .Net Framework 库来开发程序，还不如直接选择 C# 或者 VB.NET 更方便了。

MFC项目

​        这个可能大家都听过，微软的VC++中很早就有了，是对微软API的封装，简化开发流程，可以做出带界面的程序。生成的文件可以是EXE的，也可以是DLL的。其中DLL包括普通的DLL，也可以是 ActiveX 的组件式DLL，比如可以给微软的 IE 写个插件啊。咱们VC驿站之前的很多教程都用到了MFC，以后会给到大家详细介绍讲解的。

Win32项目（现在应该可能大概是64吧）

​        主要就是调用微软的API函数进行程序开发，可以开发出EXE程序，也可以开发出DLL程序。其中EXE的程序可以带窗口的，也可以是不带窗口的，也可以是基于命令行模式的环境运行，等等。

## 以Hello World为例

```c++
#include <iostream>        //包含系统的头文件
#include "stdafx.h"        //包含自己的头文件
using namespace std;       //命名空间

int _tmain(int argc, _TCHAR* argv[])    //入口点函数
{
    cout << "Hello World!" << endl;     //输出内容并换行
    return 0;            //返回
}  
```

命名空间的作用：防止重名冲突

_t 好像是适应宽字节啥的

删去头文件stdafx.h、_tmain改成main等等之类的操作，让它变成用dev写的熟悉点的C++程序的样子也是可以的

## 数据类型

### 分类

![](1.jpg)

### 各数据类型占用空间大小

**空间大小衡量标准**

1B   = 8bit（比特）
1KB = 1024B（字节）
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB

**使用重点**

各数据类型占用空间大小要用时具体查查百度就行了

使用重点：要兼顾扩展性与占用空间两方面的需求。小了不够用，容易溢出越界，大了既占用空间，又不利于网络传输

## 常量

### 分类

数值常量：整型、浮点型

字符常量：普通字符常量、转义字符常量、字符串常量

![](2.jpg)

符号常量：宏定义（eg. #define PRICE 30）

### \n和\r的区别

语句结尾打上

\n：转到下一行同一个位置

\r：是回到当前行的行首

\r\n：转到下一行的行首

Windows系统中，每行结尾是\r\n（大概是这样吧）

Enter键：回车换行键，简称回车键

**大致是这样的一个意思，具体的查百度也是含糊的说辞，等以后遇到了再纠正**

## 变量

### 命名规则

只能由数字、字母、下划线三种字符组成。

而且第一个字符不能是数字，必须是字母或者下划线。

命名建议：以用途命名

匈牙利命名法：在变量前面加一个字母来表示变量的类型（eg. iSum，cSex ，i 表示 整型的 int，c 表示字符型的 char ）

### 常变量

**定义**

常变量是这样一个变量——

变量在赋初值之后就不能改变了，即要求定义的时候必须赋值。

常变量在声明之后立即被初始化（可以用值初始化，也可以用表达式进行初始化）。使用表达式初始化时，系统化先计算出表达式的值，然后将值赋给常变量。

区别规则——

在变量定义的前面加上 const 关键字，例如：const int sum = 100;

**常变量Vs宏定义**

概述：

​        宏定义#define 是属于C语言的东西，C++为了兼容C语言，所以保留了下来，不过在C++中更建议使用常变量来定义。就好像C语言中使用 printf 来输出打印字符串，在C++中建议使用 cout 一样。不过C++中都是支持的。

具体：（百度出来的）

1. define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存。
    const定义的常量，在程序运行时在常量表中，系统为它分配内存。

2. define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。
    const定义的常量，在编译时进行严格的类型检验，可以避免出错。

3. define定义表达式时要注意“边缘效应”，例如如下定义：
      #define N 2+3 //我们预想的N值是5，我们这样使用N
      int a = N/2;  //我们预想的a的值是2.5，可实际上a的值是3.5
    原因在于在预处理阶段，编译器将 a = N/2处理成了 a = 2+3/2；

  这就是宏定义的字符串替换的“边缘效应”。因此要如下定义：
      #define N (2+3)
  const定义表达式没有上述问题。

const定义的常量叫做常变量原因有二：

1. const定义常量像变量一样检查类型
2. const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同（系统在静态区给常变量分配内存单元，普通变量是在堆栈区分配内存单元）

## 运算符

### 分类

■ 算术运算符：
+（加）、-（减）、*（乘）、/（除）、%（整除求余）、++（自加）、--（自减）

■ 关系运算符：
\>（大于）、<（小于）、==（等于）、>=（大于或等于）、<=（小于或等于）、!=（不等于）

■ 逻辑运算符：
&&（逻辑与）、||（逻辑或）、!（逻辑非）

■ 位运算符：
<<（按位左移）、>>（按位右移）、&（按位与）、|（按位或）、^（按位异或）、~（按位取反）

■ 赋值运算符：（=号及其扩展赋值运算符）
■ 条件运算符：（?:）
■ 逗号运算符：（,）
■ 指针运算符：（*）
■ 引用运算符和地址运算符：（&）
■ 求字节数运算符：（sizeof）
■ 强制类型转换运算符：（(类型) 或 类型()）
■ 成员运算符：（.）
■ 指向成员的运算符：（->）
■ 下标运算符：（[]）
■ 其他运算符：（如函数调用运算符()）  

### 算术运算符

/ ：求商，不是简单的÷

% ：取余，要求两侧均为整数，否则会报错

### 混合类型运算规则

在表达式遇到不同数据类型的混合运算时，要求不同类型的数据要先转换成同一类型然后才能进行运算。

默认编译器会有个规则进行自动转换，自动转换遵循以下规则：

1. 若参与运算的两个参数类型不同，则先转换成同一类型，然后再进行运算；

2. 按照数据长度增加的方向进行（即：由 少字节类型 向 多字节类型 转换），以保证精度不丢失；

3. 所有的浮点运算都是以双精度进行的，即使仅含 float 单精度量运算的表达式，也要先转换成 double 类型，再作运算；

4. char 类型 和 short 类型参与运算时，必须先转换成 int 类型，也就是说最小的运算整形单位是 int；

5. 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型（右随左变）。如果右边的数据类型的长度比左边长时，将丢失一部分数据，这样会降低精度，例如：int x = 2.5;

   > 【注】
   >
   > 浮点型常数的默认类型是double类型，如0.5 ，123.45等
   > 若想得到float类型常数，则要在常数后加f 字符，如：0.5f , 123.45f等
   >
   > 当把double类型数据赋值给float类型变量时，系统编译时会报警告：从double到float截断

![](3.jpg)

其中，**横向的箭头表示**必定的转换，即使是两个char型的数据相加减，每个数都先转换为int，然后在运算；**纵向箭头表示**当运算对象为不同类型时转换的方向。例如int型与double数据进行运算时，先将int型转换为double型，然后在两个double型数据间进行运算，结果为double型。  

注意：无论是 自动转换 还是 强制转换 ，都只是为了本次运算的需要而对变量的数据长度进行的**临时性转换**，不会改变数据说明时对该变量定义的类型。

### 强制类型转换运算符

强制类型转换有两种表达形式（就是括号位置不一样）：
int x = 2;
float y = 3.6;
x = (int)y;
y = float(x);

### 自增自减运算符

新理解：x++ 和 ++x 的区别在于 —— 整个 x++ 和 ++x 表达式的值不同

> 不管是 x++ 还是 ++x 执行完之后，x变量自己的值都进行了+1，但是针对整个 x++或者++x的值就不一样了。x++执行之后，这个表达式的值还是x+1之前的值，++x执行之后，这个表达式的值是x+1之后的值。

## 赋值运算符和赋值表达式

### 赋值运算符

> 总结一个原则：多的给少的会丢失，少的给多的没事儿。

多的给少的要注意的两点：1. 精度丢失   2. 取值范围越界（eg. short q = 50000）

> 复习时想到一个问题：为什么int和float类型都占有4个字节，但是float类型表示范围却比int类型大好多？
>
> 原因： int类型是直接以二进制形式保存，而float类型是以指数形式保存 
>
> 具体可以查看  https://blog.csdn.net/C2681595858/article/details/84865920  

### 复合赋值运算符

支持复合赋值的运算符：

+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=

### 逗号表达式

规则：

所有以逗号间隔的表达式都进行计算，各个表达式的计算顺序按照从左往右。整个表达式的值是最后一个逗号表达式的值。

例如：
int x = 0;
int y = 0;
x +=2, y+= 3;
int q = ((x++), (++y));

上面表达式中的最外层的**括号是必需的**，因为逗号运算符的优先级低于赋值操作符。

### 运算符的优先级

![](4.jpg)